<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>context here</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="chat-container">
        <div class="chat-header">
            <div class="action-icon">
                <img src="icons/llm2.svg" alt=" ">
            </div>
            <div class="header-text">
                <span class="app-title">Prompt Optimizer</span>
                <span class="selected-prompt-name" id="selectedPromptName"></span>
            </div>

        </div>

        <div class="chat-content">
            <div class="placeholder-overlay" id="placeholderOverlay">Optimize your prompt...</div>
            <textarea id="chatTextArea" class="chat-text-area" aria-label="Chat text area"></textarea>
        </div>

        <div class="input-container">
            <div class="input-left">

                <!--    API BUTT    -->


                <button class="input-icon" id="apiButton" type="button" aria-label="API settings"
                    data-tooltip="API">#</button>


                <!--    PROMPT BUTT    -->

                <button class="input-icon" id="promptButton" type="button" aria-label="Open prompt editor"
                    data-tooltip="Prompt">@</button>
            </div>


            <!--    DROPDOWN    -->

            <div class="input-right">
                <div class="model-selector" id="modelSelector">
                    <span id="selectedModel">Loading...</span>
                    <span class="dropdown-arrow">▼</span>
                    <div class="model-dropdown" id="modelDropdown">
                        <div class="model-option">Loading models...</div>
                    </div>
                </div>

                <!--    OPTIMIZE BUTT    -->


                <button class="action-icon" id="sendButton" type="button" aria-label="Send message"
                    data-tooltip="Optimize">
                    <img src="icons/llm2.svg" alt="Send">
                </button>

                <!--    COPY BUTT    -->

                <button class="action-icon" id="copyButton" type="button" aria-label="Copy text" data-tooltip="Copy">
                    <img src="icons/copy.svg" alt="Copy">
                </button>

                <!--    CLEAR BUTT    -->

                <button class="action-icon" id="clearButton" type="button" aria-label="Clear text" data-tooltip="Clear">
                    <img src="icons/sync.svg" alt="Clear">
                </button>



            </div>



        </div>
    </div>
    </div>

    <!-- API Key Modal -->
    <div class="api-modal" id="apiModal">
        <div class="api-modal-content">
            <div class="api-modal-header">Groq API Key</div>
            <div class="api-status" id="apiStatus"></div>
            <input type="password" class="api-input" id="apiKeyInput" placeholder="Enter your Groq API key">
            <div class="api-modal-buttons">
                <button class="api-button" id="cancelButton">Cancel</button>
                <button class="api-button primary" id="saveButton">Save</button>
            </div>
        </div>
    </div>

    <!-- System Prompt Modal -->
    <!-- 
    RECOMMENDED SYSTEM PROMPT FOR PROMPT REFINEMENT:
    
    You are a prompt optimization specialist. Your role is EXCLUSIVELY to refine and improve user prompts.

    CRITICAL RULES:
    - You MUST NOT execute, implement, or fulfill the task described in the prompt
    - You MUST NOT generate code, write content, create documents, or perform any requested action
    - You ONLY analyze the prompt and rewrite it to be clearer, more specific, and more effective
    - You ONLY output the refined prompt itself, with no explanations or additional text

    PROCESS:
    1. Analyze the user's raw prompt for clarity, specificity, and effectiveness
    2. Identify ambiguities, missing context, or areas that need improvement
    3. Rewrite the prompt to be more precise and actionable
    4. Return ONLY the improved prompt

    EXAMPLES:
    Input: "make me an html page"
    Output: "Create a complete HTML5 page with proper document structure including <!DOCTYPE>, <head> with meta tags and title, and a <body> section. Include semantic HTML elements and basic CSS styling."

    Input: "write code for sorting"
    Output: "Write a Python function that implements the quicksort algorithm to sort a list of integers in ascending order. Include docstrings, type hints, and handle edge cases like empty lists."
    -->
    <div class="api-modal" id="promptModal" role="dialog" aria-labelledby="promptModalTitle" aria-modal="true">
        <div class="api-modal-content prompt-modal-large">
            <div class="api-modal-header" id="promptModalTitle">Create Custom Prompt</div>
            <div class="api-status" id="promptStatus"></div>

            <div class="form-group">
                <label for="promptNameInput" class="form-label">Prompt Name *</label>
                <input type="text" class="api-input" id="promptNameInput" placeholder="Enter a name for your prompt"
                    required>
            </div>

            <div class="form-group">
                <label for="promptDescInput" class="form-label">Description (optional)</label>
                <input type="text" class="api-input" id="promptDescInput"
                    placeholder="Brief description of what this prompt does">
            </div>

            <div class="form-group">
                <label for="promptInput" class="form-label">Prompt Content *</label>
                <textarea class="prompt-input" id="promptInput"
                    placeholder="Enter your prompt content here...&#10;&#10;Example:&#10;You are a helpful assistant that..."></textarea>
            </div>

            <div class="api-modal-buttons">
                <button class="api-button" id="promptCancelButton">Cancel</button>
                <button class="api-button primary" id="promptSaveButton">Save</button>
            </div>
        </div>
    </div>

    <!-- Prompt Selector Modal -->
    <div class="api-modal" id="promptSelectorModal" role="dialog" aria-labelledby="promptSelectorTitle"
        aria-modal="true">
        <div class="api-modal-content prompt-selector-large">
            <div class="api-modal-header">
                <span id="promptSelectorTitle">Select a Prompt</span>
            </div>

            <div class="prompt-selector-content" id="promptSelectorContent">
                <div class="loading-state">Loading prompts...</div>
            </div>

            <div class="prompt-selector-footer">
                <button class="api-button primary" id="createCustomPromptBtn">
                    + New Prompt
                </button>
                <button class="api-button" id="promptSelectorCloseBtn">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Prompt Preview Modal -->
    <div class="api-modal" id="promptPreviewModal" role="dialog" aria-labelledby="previewPromptName" aria-modal="true">
        <div class="api-modal-content prompt-preview-large">
            <div class="api-modal-header">
                <span id="previewPromptName">Prompt Preview</span>
                <button class="modal-close-btn" id="promptPreviewCloseBtn" aria-label="Close modal">&times;</button>
            </div>

            <div class="prompt-preview-metadata" id="previewMetadata">
                <div class="metadata-item">
                    <span class="metadata-label">Category:</span>
                    <span class="metadata-value" id="previewCategory"></span>
                </div>
                <div class="metadata-item">
                    <span class="metadata-label">Description:</span>
                    <span class="metadata-value" id="previewDescription"></span>
                </div>
                <div class="metadata-item" id="previewTagsContainer">
                    <span class="metadata-label">Tags:</span>
                    <span class="metadata-value" id="previewTags"></span>
                </div>
            </div>

            <div class="prompt-preview-content">
                <pre id="previewContent"></pre>
            </div>

            <div class="prompt-preview-footer">
                <button class="api-button" id="previewBackBtn">Back</button>
                <button class="api-button primary" id="previewUseBtn">Use This Prompt</button>
            </div>
        </div>
    </div>


</body>

</html>

<script>
    // PromptLoader Class - Handles loading and parsing of prompt files
    class PromptLoader {
        constructor(manifestPath = '/prompts/index.json') {
            this.manifestPath = manifestPath;
            this.cache = new Map();
            this.manifestCache = null;
        }

        /**
         * Load and parse the manifest file
         * @returns {Promise<Array>} Array of prompt metadata from manifest
         */
        async loadManifest() {
            // Return cached manifest if available
            if (this.manifestCache) {
                return this.manifestCache;
            }

            try {
                const response = await fetch(this.manifestPath);

                if (!response.ok) {
                    throw new Error(`Failed to fetch manifest: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();

                // Validate manifest structure
                if (!data || !Array.isArray(data.prompts)) {
                    throw new Error('Invalid manifest format: missing prompts array');
                }

                // Cache the manifest
                this.manifestCache = data.prompts;
                console.log(`✓ Loaded manifest with ${data.prompts.length} prompts`);

                return this.manifestCache;
            } catch (error) {
                console.error('Error loading manifest:', error);
                // Return empty array on error to allow graceful degradation
                this.manifestCache = [];
                throw error;
            }
        }

        /**
         * Parse YAML frontmatter from markdown content
         * @param {string} markdown - Raw markdown content with optional frontmatter
         * @returns {Object} Object with metadata and content properties
         */
        parseFrontmatter(markdown) {
            const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
            const match = markdown.match(frontmatterRegex);

            if (!match) {
                // No frontmatter found, return entire content
                return {
                    metadata: {},
                    content: markdown.trim()
                };
            }

            const frontmatterText = match[1];
            const content = match[2].trim();
            const metadata = {};

            try {
                // Simple YAML parser for key-value pairs
                const lines = frontmatterText.split('\n');

                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine || trimmedLine.startsWith('#')) continue;

                    // Match key: value or key: "value" or key: [array]
                    const keyValueMatch = trimmedLine.match(/^([^:]+):\s*(.+)$/);
                    if (keyValueMatch) {
                        const key = keyValueMatch[1].trim();
                        let value = keyValueMatch[2].trim();

                        // Handle quoted strings
                        if ((value.startsWith('"') && value.endsWith('"')) ||
                            (value.startsWith("'") && value.endsWith("'"))) {
                            value = value.slice(1, -1);
                        }
                        // Handle arrays
                        else if (value.startsWith('[') && value.endsWith(']')) {
                            value = value.slice(1, -1)
                                .split(',')
                                .map(item => item.trim().replace(/^["']|["']$/g, ''));
                        }

                        metadata[key] = value;
                    }
                }

                return { metadata, content };
            } catch (error) {
                console.warn('Error parsing frontmatter, using raw content:', error);
                return {
                    metadata: {},
                    content: markdown.trim()
                };
            }
        }

        /**
         * Load an individual prompt file
         * @param {string} promptId - The prompt ID from the manifest
         * @param {string} filename - The filename of the prompt
         * @returns {Promise<Object>} PromptData object with full metadata and content
         */
        async loadPrompt(promptId, filename) {
            // Check cache first
            if (this.cache.has(promptId)) {
                return this.cache.get(promptId);
            }

            try {
                const promptPath = `/prompts/${filename}`;
                const response = await fetch(promptPath);

                if (!response.ok) {
                    throw new Error(`Failed to fetch prompt file: ${response.status} ${response.statusText}`);
                }

                const markdown = await response.text();
                const { metadata, content } = this.parseFrontmatter(markdown);

                // Build PromptData object
                const promptData = {
                    id: promptId,
                    name: metadata.name || filename.replace('.md', ''),
                    description: metadata.description || '',
                    content: content,
                    category: metadata.category || 'general',
                    tags: Array.isArray(metadata.tags) ? metadata.tags : [],
                    author: metadata.author || '',
                    version: metadata.version || '',
                    source: 'file',
                    featured: false // Will be set from manifest
                };

                // Cache the prompt
                this.cache.set(promptId, promptData);
                console.log(`✓ Loaded prompt: ${promptData.name}`);

                return promptData;
            } catch (error) {
                console.error(`Error loading prompt ${promptId}:`, error);
                throw error;
            }
        }

        /**
         * Load all prompts from the manifest
         * @returns {Promise<Array>} Array of PromptData objects
         */
        async loadAllPrompts() {
            try {
                const manifest = await this.loadManifest();
                const prompts = [];

                for (const item of manifest) {
                    try {
                        const promptData = await this.loadPrompt(item.id, item.file);
                        // Set featured flag from manifest
                        promptData.featured = item.featured || false;
                        prompts.push(promptData);
                    } catch (error) {
                        // Skip individual prompt errors but continue loading others
                        console.warn(`Skipping prompt ${item.id} due to error:`, error);
                    }
                }

                return prompts;
            } catch (error) {
                console.error('Error loading all prompts:', error);
                return []; // Return empty array on error
            }
        }
    }

    // CustomPromptManager Class - Handles localStorage operations for custom prompts
    class CustomPromptManager {
        static STORAGE_KEY = 'customPrompts';

        /**
         * Generate a unique ID for a custom prompt
         * @returns {string} Unique timestamp-based ID
         */
        static generateId() {
            return `custom-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        }

        /**
         * Save a custom prompt to localStorage
         * @param {Object} promptData - Prompt data to save
         * @param {string} promptData.name - Display name for the prompt
         * @param {string} promptData.content - Full prompt text
         * @param {string} [promptData.description] - Optional description
         * @param {string} [promptData.category] - Optional category
         * @param {Array<string>} [promptData.tags] - Optional tags array
         * @param {string} [promptData.id] - Optional ID for updates (generates new if not provided)
         * @returns {Object} Saved prompt data with metadata
         */
        static save(promptData) {
            try {
                const prompts = this.list();
                const now = new Date().toISOString();

                // Check if updating existing prompt
                const existingIndex = promptData.id ?
                    prompts.findIndex(p => p.id === promptData.id) : -1;

                const prompt = {
                    id: promptData.id || this.generateId(),
                    name: promptData.name,
                    description: promptData.description || '',
                    content: promptData.content,
                    category: promptData.category || 'custom',
                    tags: Array.isArray(promptData.tags) ? promptData.tags : [],
                    author: 'User',
                    version: '1.0',
                    source: 'custom',
                    featured: false,
                    createdAt: existingIndex >= 0 ? prompts[existingIndex].createdAt : now,
                    updatedAt: now
                };

                if (existingIndex >= 0) {
                    // Update existing prompt
                    prompts[existingIndex] = prompt;
                    console.log(`✓ Updated custom prompt: ${prompt.name}`);
                } else {
                    // Add new prompt
                    prompts.push(prompt);
                    console.log(`✓ Saved new custom prompt: ${prompt.name}`);
                }

                localStorage.setItem(this.STORAGE_KEY, JSON.stringify(prompts));
                return prompt;
            } catch (error) {
                console.error('Error saving custom prompt:', error);
                throw new Error('Failed to save custom prompt');
            }
        }

        /**
         * Load a single custom prompt by ID
         * @param {string} promptId - The ID of the prompt to load
         * @returns {Object|null} Prompt data or null if not found
         */
        static load(promptId) {
            try {
                const prompts = this.list();
                const prompt = prompts.find(p => p.id === promptId);

                if (prompt) {
                    console.log(`✓ Loaded custom prompt: ${prompt.name}`);
                    return prompt;
                }

                console.warn(`Custom prompt not found: ${promptId}`);
                return null;
            } catch (error) {
                console.error('Error loading custom prompt:', error);
                return null;
            }
        }

        /**
         * List all custom prompts from localStorage
         * @returns {Array<Object>} Array of custom prompt objects
         */
        static list() {
            try {
                const data = localStorage.getItem(this.STORAGE_KEY);

                if (!data) {
                    return [];
                }

                const prompts = JSON.parse(data);

                // Validate that it's an array
                if (!Array.isArray(prompts)) {
                    console.warn('Invalid custom prompts data, resetting to empty array');
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify([]));
                    return [];
                }

                return prompts;
            } catch (error) {
                console.error('Error listing custom prompts, corrupted data:', error);
                // Reset corrupted data
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify([]));
                return [];
            }
        }

        /**
         * Delete a custom prompt by ID
         * @param {string} promptId - The ID of the prompt to delete
         * @returns {boolean} True if deleted, false if not found
         */
        static delete(promptId) {
            try {
                const prompts = this.list();
                const index = prompts.findIndex(p => p.id === promptId);

                if (index >= 0) {
                    const deletedPrompt = prompts[index];
                    prompts.splice(index, 1);
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(prompts));
                    console.log(`✓ Deleted custom prompt: ${deletedPrompt.name}`);
                    return true;
                }

                console.warn(`Custom prompt not found for deletion: ${promptId}`);
                return false;
            } catch (error) {
                console.error('Error deleting custom prompt:', error);
                throw new Error('Failed to delete custom prompt');
            }
        }

        /**
         * Check if a prompt ID is a custom prompt
         * @param {string} promptId - The ID to check
         * @returns {boolean} True if custom prompt
         */
        static isCustomPrompt(promptId) {
            return promptId && promptId.startsWith('custom-');
        }

        /**
         * Clear all custom prompts (use with caution)
         * @returns {number} Number of prompts cleared
         */
        static clearAll() {
            try {
                const prompts = this.list();
                const count = prompts.length;
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify([]));
                console.log(`✓ Cleared ${count} custom prompts`);
                return count;
            } catch (error) {
                console.error('Error clearing custom prompts:', error);
                throw new Error('Failed to clear custom prompts');
            }
        }
    }

    // PromptSelector Class - Handles prompt selection UI and interactions
    class PromptSelector {
        constructor(containerElement, onSelectCallback) {
            this.container = containerElement;
            this.onSelect = onSelectCallback;
            this.promptLoader = new PromptLoader();
            this.allPrompts = [];
            this.currentPreviewPrompt = null;
            this.initialized = false;
        }

        /**
         * Initialize the prompt selector by loading all prompts
         * @returns {Promise<void>}
         */
        async initialize() {
            if (this.initialized) {
                return;
            }

            try {
                this.showLoading();

                // sed prompts
                const filePrompts = await this.promptLoader.loadAllPrompts();

                // Load custom prompts
                const customPrompts = CustomPromptManager.list();

                // Combine both sources
                this.allPrompts = [...filePrompts, ...customPrompts];

                console.log(`✓ Initialized PromptSelector with ${this.allPrompts.length} prompts`);

                this.initialized = true;
                this.render();
            } catch (error) {
                console.error('Error initializing PromptSelector:', error);
                this.showError('Failed to load prompts. Please try again.');
            }
        }

        /**
         * Show loading state
         */
        showLoading() {
            this.container.innerHTML = '<div class="loading-state">Loading prompts...</div>';
        }

        /**
         * Show error state
         * @param {string} message - Error message to display
         */
        showError(message) {
            this.container.innerHTML = `<div class="empty-state">${message}</div>`;
        }

        /**
         * Render the prompt list
         */
        render() {
            // Sort prompts: featured first, then alphabetically by name
            const sortedPrompts = [...this.allPrompts].sort((a, b) => {
                if (a.featured && !b.featured) return -1;
                if (!a.featured && b.featured) return 1;
                return a.name.localeCompare(b.name);
            });

            if (sortedPrompts.length === 0) {
                this.container.innerHTML = `
                    <div class="empty-state">
                        No prompts found. Try adjusting your search or create a custom prompt.
                    </div>
                `;
                return;
            }

            // Generate HTML for all prompt cards
            const cardsHTML = sortedPrompts.map(prompt => this.createPromptCard(prompt)).join('');
            this.container.innerHTML = cardsHTML;

            // Attach event listeners
            this.attachEventListeners();
        }

        /**
         * Create HTML for a single prompt card
         * @param {Object} prompt - Prompt data
         * @returns {string} HTML string
         */
        createPromptCard(prompt) {
            const isCustom = prompt.source === 'custom';
            const badges = [];

            // Check if this prompt is currently selected
            const selectedPromptId = localStorage.getItem('selectedPromptId');
            const currentSystemPrompt = localStorage.getItem('systemPrompt');

            // Check by ID first, then fallback to content match
            const isSelected = selectedPromptId === prompt.id ||
                (currentSystemPrompt && currentSystemPrompt === prompt.content);
            const selectedClass = isSelected ? ' selected' : '';

            // Debug logging
            console.log(`Prompt: ${prompt.name}, ID: ${prompt.id}, Selected ID: ${selectedPromptId}, Is Selected: ${isSelected}`);

            if (prompt.featured) {
                badges.push('<span class="badge badge-featured">Featured</span>');
            }
            // Only show category badge if it's not 'custom'
            if (prompt.category && prompt.category !== 'custom') {
                badges.push(`<span class="badge badge-category">${prompt.category}</span>`);
            }

            const tagsHTML = prompt.tags && prompt.tags.length > 0
                ? `<div class="prompt-card-tags">
                    ${prompt.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                   </div>`
                : '';

            const editDeleteButtons = isCustom
                ? `<button class="card-button" data-action="edit" data-id="${prompt.id}">Edit</button>
                   <button class="card-button danger" data-action="delete" data-id="${prompt.id}">Delete</button>`
                : '';

            return `
                <div class="prompt-card${selectedClass}" data-id="${prompt.id}" data-action="select">
                    <div class="prompt-card-compact">
                        <div class="prompt-card-left">
                            <div class="prompt-card-title">${this.escapeHtml(prompt.name)}</div>
                            ${badges.length > 0 ? `<div class="prompt-card-badges">${badges.join('')}</div>` : ''}
                        </div>
                        <div class="prompt-card-actions">
                            <button class="card-button" data-action="preview" data-id="${prompt.id}">Preview</button>
                            ${editDeleteButtons}
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * Attach event listeners to prompt cards
         */
        attachEventListeners() {
            const cards = this.container.querySelectorAll('.prompt-card');

            cards.forEach(card => {
                // Handle card click to select prompt
                card.addEventListener('click', (e) => {
                    // Only trigger if clicking on the card itself, not on buttons
                    if (e.target.tagName !== 'BUTTON' && !e.target.closest('button')) {
                        const promptId = card.getAttribute('data-id');
                        console.log('Card clicked, selecting prompt:', promptId);

                        // Add immediate visual feedback
                        card.style.transform = 'scale(0.98)';
                        setTimeout(() => {
                            card.style.transform = '';
                        }, 150);

                        this.handleAction('select', promptId);
                    }
                });

                // Handle button clicks
                const buttons = card.querySelectorAll('button[data-action]');
                buttons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const action = button.getAttribute('data-action');
                        const promptId = button.getAttribute('data-id');
                        this.handleAction(action, promptId);
                    });
                });
            });
        }

        /**
         * Handle button actions
         * @param {string} action - Action type (preview, select, edit, delete)
         * @param {string} promptId - Prompt ID
         */
        handleAction(action, promptId) {
            const prompt = this.allPrompts.find(p => p.id === promptId);

            if (!prompt) {
                console.error('Prompt not found:', promptId);
                return;
            }

            switch (action) {
                case 'preview':
                    this.showPreview(prompt);
                    break;
                case 'select':
                    this.handleSelection(prompt);
                    break;
                case 'edit':
                    this.handleEdit(prompt);
                    break;
                case 'delete':
                    this.handleDelete(prompt);
                    break;
            }
        }

        /**
         * Handle prompt selection
         * @param {Object} prompt - Selected prompt data
         */
        handleSelection(prompt) {
            try {
                // Update localStorage with selected prompt
                localStorage.setItem('systemPrompt', prompt.content);
                localStorage.setItem('selectedPromptId', prompt.id);
                localStorage.setItem('selectedPromptName', prompt.name);

                console.log(`✓ Selected prompt: ${prompt.name} (ID: ${prompt.id})`);

                // Re-render to show the new selection highlighting
                this.render();

                // Trigger callback
                if (this.onSelect) {
                    this.onSelect(prompt);
                }

                // Don't close modal - let user close it manually
            } catch (error) {
                console.error('Error selecting prompt:', error);
                alert('Failed to select prompt. Please try again.');
            }
        }

        /**
         * Show preview modal for a prompt
         * @param {Object} prompt - Prompt to preview
         */
        showPreview(prompt) {
            this.currentPreviewPrompt = prompt;

            // Populate preview modal
            document.getElementById('previewPromptName').textContent = prompt.name;
            document.getElementById('previewCategory').textContent = prompt.category;
            document.getElementById('previewDescription').textContent = prompt.description || 'No description';

            const tagsContainer = document.getElementById('previewTagsContainer');
            if (prompt.tags && prompt.tags.length > 0) {
                document.getElementById('previewTags').textContent = prompt.tags.join(', ');
                tagsContainer.style.display = 'flex';
            } else {
                tagsContainer.style.display = 'none';
            }

            document.getElementById('previewContent').textContent = prompt.content;

            // Show preview modal, hide selector modal
            document.getElementById('promptSelectorModal').classList.remove('show');
            document.getElementById('promptPreviewModal').classList.add('show');
        }

        /**
         * Handle edit action for custom prompts
         * @param {Object} prompt - Prompt to edit
         */
        handleEdit(prompt) {
            // Store prompt data for editing
            window.editingPrompt = prompt;

            // Close selector modal
            document.getElementById('promptSelectorModal').classList.remove('show');

            // Open prompt modal in edit mode
            const promptModal = document.getElementById('promptModal');
            const promptInput = document.getElementById('promptInput');

            promptInput.value = prompt.content;
            promptModal.classList.add('show');
            promptInput.focus();
        }

        /**
         * Handle delete action for custom prompts
         * @param {Object} prompt - Prompt to delete
         */
        handleDelete(prompt) {
            if (confirm(`Are you sure you want to delete "${prompt.name}"?`)) {
                try {
                    CustomPromptManager.delete(prompt.id);

                    // Remove from local arrays
                    this.allPrompts = this.allPrompts.filter(p => p.id !== prompt.id);

                    // Re-render
                    this.render();

                    console.log(`✓ Deleted prompt: ${prompt.name}`);
                } catch (error) {
                    console.error('Error deleting prompt:', error);
                    alert('Failed to delete prompt. Please try again.');
                }
            }
        }

        /**
         * Escape HTML to prevent XSS
         * @param {string} text - Text to escape
         * @returns {string} Escaped text
         */
        escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Refresh the prompt list (reload from sources)
         */
        async refresh() {
            this.initialized = false;
            await this.initialize();
        }
    }
</script>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const textArea = document.getElementById('chatTextArea');
        const copyButton = document.getElementById('copyButton');
        const placeholderOverlay = document.getElementById('placeholderOverlay');

        // Ensure textarea is empty on load
        textArea.value = '';
        placeholderOverlay.classList.remove('hidden');

        // Hide placeholder when textarea is clicked or focused
        textArea.addEventListener('click', () => {
            placeholderOverlay.classList.add('hidden');
        });

        textArea.addEventListener('focus', () => {
            placeholderOverlay.classList.add('hidden');
            textArea.setAttribute('aria-live', 'polite');
        });

        // Show placeholder again if textarea is empty and loses focus
        textArea.addEventListener('blur', () => {
            if (textArea.value.length === 0) {
                placeholderOverlay.classList.remove('hidden');
            }
            textArea.removeAttribute('aria-live');
        });

        // Also handle input event to show/hide placeholder
        textArea.addEventListener('input', () => {
            if (textArea.value.length > 0) {
                placeholderOverlay.classList.add('hidden');
            } else {
                placeholderOverlay.classList.remove('hidden');
            }
        });

        // Copy text
        copyButton.addEventListener('click', () => {
            textArea.select();
            document.execCommand('copy');
            textArea.setSelectionRange(textArea.value.length, textArea.value.length);
        });

        // Custom Prompt Editor Modal
        const promptModal = document.getElementById('promptModal');
        const promptModalTitle = document.getElementById('promptModalTitle');
        const promptNameInput = document.getElementById('promptNameInput');
        const promptDescInput = document.getElementById('promptDescInput');
        const promptInput = document.getElementById('promptInput');
        const promptStatus = document.getElementById('promptStatus');
        const promptSaveButton = document.getElementById('promptSaveButton');
        const promptCancelButton = document.getElementById('promptCancelButton');

        // Function to open prompt modal for creating new prompt
        function openCreatePromptModal() {
            window.editingPrompt = null;
            promptModalTitle.textContent = 'Create Custom Prompt';
            promptNameInput.value = '';
            promptDescInput.value = '';
            promptInput.value = '';
            promptStatus.textContent = '';
            promptModal.classList.add('show');
            promptNameInput.focus();
        }

        // Function to open prompt modal for editing
        function openEditPromptModal(prompt) {
            window.editingPrompt = prompt;
            promptModalTitle.textContent = 'Edit Custom Prompt';
            promptNameInput.value = prompt.name;
            promptDescInput.value = prompt.description || '';
            promptInput.value = prompt.content;
            promptStatus.textContent = '';
            promptModal.classList.add('show');
            promptNameInput.focus();
        }

        promptCancelButton.addEventListener('click', () => {
            promptModal.classList.remove('show');
            window.editingPrompt = null;

            // Reopen the prompt selector modal
            document.getElementById('promptSelectorModal').classList.add('show');
        });

        promptSaveButton.addEventListener('click', () => {
            const name = promptNameInput.value.trim();
            const description = promptDescInput.value.trim();
            const content = promptInput.value.trim();

            // Validation
            if (!name) {
                promptStatus.textContent = 'Please enter a prompt name';
                promptStatus.className = 'api-status error';
                return;
            }

            if (!content) {
                promptStatus.textContent = 'Please enter prompt content';
                promptStatus.className = 'api-status error';
                return;
            }

            try {
                const promptData = {
                    name,
                    description,
                    content,
                    category: 'custom',
                    tags: []
                };

                // If editing, preserve the ID
                if (window.editingPrompt) {
                    promptData.id = window.editingPrompt.id;
                }

                const savedPrompt = CustomPromptManager.save(promptData);

                promptStatus.textContent = window.editingPrompt ?
                    'Prompt updated successfully!' :
                    'Prompt created successfully!';
                promptStatus.className = 'api-status success';

                setTimeout(() => {
                    // Close the custom prompt modal
                    promptModal.classList.remove('show');
                    window.editingPrompt = null;

                    // Refresh prompt selector if it exists
                    if (window.promptSelector) {
                        window.promptSelector.refresh();
                    }

                    // Reopen the prompt selector modal
                    document.getElementById('promptSelectorModal').classList.add('show');
                }, 800);
            } catch (error) {
                console.error('Error saving prompt:', error);
                promptStatus.textContent = 'Failed to save prompt. Please try again.';
                promptStatus.className = 'api-status error';
            }
        });

        // Close modal when clicking outside
        promptModal.addEventListener('click', (e) => {
            if (e.target === promptModal) {
                promptModal.classList.remove('show');
                window.editingPrompt = null;

                // Reopen the prompt selector modal
                document.getElementById('promptSelectorModal').classList.add('show');
            }
        });

        // Allow Ctrl/Cmd + Enter to save
        promptInput.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                promptSaveButton.click();
            }
        });

        // API Key Modal
        const apiButton = document.getElementById('apiButton');
        const apiModal = document.getElementById('apiModal');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const apiStatus = document.getElementById('apiStatus');
        const saveButton = document.getElementById('saveButton');
        const cancelButton = document.getElementById('cancelButton');

        apiButton.addEventListener('click', () => {
            const currentKey = localStorage.getItem('groqApiKey');
            if (currentKey) {
                apiKeyInput.value = currentKey;
                apiStatus.textContent = 'API key is currently set';
                apiStatus.className = 'api-status success';
            } else {
                apiKeyInput.value = '';
                apiStatus.textContent = 'No API key set';
                apiStatus.className = 'api-status';
            }
            apiModal.classList.add('show');
            apiKeyInput.focus();
        });

        cancelButton.addEventListener('click', () => {
            apiModal.classList.remove('show');
        });

        saveButton.addEventListener('click', () => {
            const apiKey = apiKeyInput.value.trim();
            if (apiKey) {
                localStorage.setItem('groqApiKey', apiKey);
                apiStatus.textContent = 'API key saved successfully!';
                apiStatus.className = 'api-status success';

                // Refresh models immediately
                fetchGroqModels();

                setTimeout(() => {
                    apiModal.classList.remove('show');
                }, 1000);
            } else {
                apiStatus.textContent = 'Please enter a valid API key';
                apiStatus.className = 'api-status error';
            }
        });

        // Close modal when clicking outside
        apiModal.addEventListener('click', (e) => {
            if (e.target === apiModal) {
                apiModal.classList.remove('show');
            }
        });

        // Allow Enter key to save
        apiKeyInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveButton.click();
            }
        });

        // Model selector dropdown
        const modelSelector = document.getElementById('modelSelector');
        const modelDropdown = document.getElementById('modelDropdown');
        const selectedModel = document.getElementById('selectedModel');

        // Fetch available models from Groq API
        async function fetchGroqModels() {
            const apiKey = localStorage.getItem('groqApiKey');
            if (!apiKey) {
                modelDropdown.innerHTML = '<div class="model-option error">API Key Required</div>';
                return;
            }

            // Allowed models list
            const allowedModels = [
                'openai/gpt-oss-20b',
                'moonshotai/kimi-k2-instruct-0905',
                'meta-llama/llama-4-scout-17b-16e-instruct'
            ];

            try {
                const response = await fetch('https://api.groq.com/openai/v1/models', {
                    headers: {
                        'Authorization': `Bearer ${apiKey}`
                    }
                });

                if (!response.ok) {
                    throw new Error('Failed to fetch models');
                }

                const data = await response.json();
                const models = data.data.filter(model =>
                    model.active && allowedModels.includes(model.id)
                );

                console.log(`Fetched ${models.length} allowed models:`, models.map(m => m.id));

                modelDropdown.innerHTML = '';
                models.forEach(model => {
                    const option = document.createElement('div');
                    option.className = 'model-option';
                    option.setAttribute('data-model', model.id);
                    option.textContent = model.id;
                    option.addEventListener('click', handleModelSelection);
                    modelDropdown.appendChild(option);
                });

                // Load saved model or use first available
                const savedModel = localStorage.getItem('selectedGroqModel');
                if (savedModel && models.find(m => m.id === savedModel)) {
                    selectedModel.textContent = savedModel;
                } else if (models.length > 0) {
                    selectedModel.textContent = models[0].id;
                    localStorage.setItem('selectedGroqModel', models[0].id);
                }
            } catch (error) {
                console.error('Error fetching models:', error);
                modelDropdown.innerHTML = '<div class="model-option error">Failed to load models</div>';
            }
        }

        function handleModelSelection(e) {
            e.stopPropagation();
            const modelId = e.target.getAttribute('data-model');
            selectedModel.textContent = modelId;
            modelDropdown.classList.remove('show');
            localStorage.setItem('selectedGroqModel', modelId);
        }

        modelSelector.addEventListener('click', (e) => {
            e.stopPropagation();
            modelDropdown.classList.toggle('show');
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', () => {
            modelDropdown.classList.remove('show');
        });

        // Initialize models on page load
        const apiKey = localStorage.getItem('groqApiKey');
        if (apiKey) {
            fetchGroqModels();
        } else {
            selectedModel.textContent = 'No API Key';
        }

        // Clear button functionality
        const clearButton = document.getElementById('clearButton');
        clearButton.addEventListener('click', () => {
            textArea.value = '';
            placeholderOverlay.classList.remove('hidden');
        });

        // Send button - Execute with selected model and system prompt
        const sendButton = document.getElementById('sendButton');
        sendButton.addEventListener('click', async () => {
            await sendMessage();
        });

        // Send message to Groq API with dynamic model selection
        async function sendMessage() {
            const apiKey = localStorage.getItem('groqApiKey');
            const systemPrompt = localStorage.getItem('systemPrompt') || '';
            const userMessage = textArea.value.trim();
            const selectedModelId = localStorage.getItem('selectedGroqModel');

            if (!apiKey) {
                alert('Please set your Groq API key first');
                apiButton.click();
                return;
            }

            if (!userMessage) {
                alert('Please enter a message');
                return;
            }

            if (!selectedModelId) {
                alert('Please select a model from the dropdown');
                return;
            }

            // Show loading state
            sendButton.disabled = true;
            const originalContent = sendButton.innerHTML;
            sendButton.innerHTML = '⏳';

            try {
                const messages = [];

                // Add system prompt if it exists
                if (systemPrompt) {
                    messages.push({
                        role: 'system',
                        content: systemPrompt
                    });
                }

                // Add user message
                messages.push({
                    role: 'user',
                    content: userMessage
                });

                console.log('=== Sending to Groq API ===');
                console.log('Model:', selectedModelId);
                console.log('System Prompt:', systemPrompt || '(none)');
                console.log('User Message:', userMessage);
                console.log('Messages array being sent:', JSON.stringify(messages, null, 2));

                const requestBody = {
                    model: selectedModelId,
                    messages: messages,
                    temperature: 0.7,
                    max_tokens: 2048
                };

                console.log('Full request body:', JSON.stringify(requestBody, null, 2));

                const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'API request failed');
                }

                const data = await response.json();
                const assistantMessage = data.choices[0]?.message?.content || 'No response';

                // Display only the refined prompt response
                textArea.value = assistantMessage;
                placeholderOverlay.classList.add('hidden');

            } catch (error) {
                console.error('Groq API Error:', error);
                alert(`Error: ${error.message}`);
            } finally {
                sendButton.disabled = false;
                sendButton.innerHTML = originalContent;
            }
        }

        // Send on Enter key
        textArea.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                const message = textArea.value.trim();
                if (message.length > 0) {
                    sendMessage();
                }
            }
        });

        // ===== Prompt Selector Integration =====

        // Initialize prompt selector (lazy initialization)
        const promptButton = document.getElementById('promptButton');
        const promptSelectorModal = document.getElementById('promptSelectorModal');
        const promptSelectorContent = document.getElementById('promptSelectorContent');
        const createCustomPromptBtn = document.getElementById('createCustomPromptBtn');
        const promptSelectorCloseBtn = document.getElementById('promptSelectorCloseBtn');

        // Prompt preview modal elements
        const promptPreviewModal = document.getElementById('promptPreviewModal');
        const promptPreviewCloseBtn = document.getElementById('promptPreviewCloseBtn');
        const previewBackBtn = document.getElementById('previewBackBtn');
        const previewUseBtn = document.getElementById('previewUseBtn');

        // Initialize PromptSelector instance
        window.promptSelector = null;

        // Open prompt selector when @ button is clicked
        promptButton.addEventListener('click', async () => {
            // Lazy initialization
            if (!window.promptSelector) {
                window.promptSelector = new PromptSelector(
                    promptSelectorContent,
                    (prompt) => {
                        console.log('Prompt selected:', prompt.name);
                        updateSelectedPromptIndicator(prompt);
                    }
                );
                await window.promptSelector.initialize();
            }

            promptSelectorModal.classList.add('show');
        });

        // Close prompt selector modal
        promptSelectorCloseBtn.addEventListener('click', () => {
            promptSelectorModal.classList.remove('show');
        });

        // Don't close modal when clicking outside - only close button closes it

        // Create custom prompt button
        createCustomPromptBtn.addEventListener('click', () => {
            promptSelectorModal.classList.remove('show');
            openCreatePromptModal();
        });

        // Preview modal handlers
        promptPreviewCloseBtn.addEventListener('click', () => {
            promptPreviewModal.classList.remove('show');
        });

        previewBackBtn.addEventListener('click', () => {
            promptPreviewModal.classList.remove('show');
            promptSelectorModal.classList.add('show');
        });

        previewUseBtn.addEventListener('click', () => {
            if (window.promptSelector && window.promptSelector.currentPreviewPrompt) {
                window.promptSelector.handleSelection(window.promptSelector.currentPreviewPrompt);
                promptPreviewModal.classList.remove('show');
            }
        });

        // Close preview modal when clicking outside
        promptPreviewModal.addEventListener('click', (e) => {
            if (e.target === promptPreviewModal) {
                promptPreviewModal.classList.remove('show');
            }
        });

        // Keyboard navigation for modals
        document.addEventListener('keydown', (e) => {
            // Escape key closes modals
            if (e.key === 'Escape') {
                if (promptPreviewModal.classList.contains('show')) {
                    promptPreviewModal.classList.remove('show');
                } else if (promptSelectorModal.classList.contains('show')) {
                    promptSelectorModal.classList.remove('show');
                } else if (promptModal.classList.contains('show')) {
                    promptModal.classList.remove('show');
                    window.editingPrompt = null;
                }
            }
        });

        // Update selected prompt indicator
        function updateSelectedPromptIndicator(prompt) {
            const selectedPromptNameEl = document.getElementById('selectedPromptName');
            if (prompt && prompt.name) {
                selectedPromptNameEl.textContent = `Using: ${prompt.name}`;
                selectedPromptNameEl.title = prompt.description || prompt.name;
            } else {
                selectedPromptNameEl.textContent = '';
                selectedPromptNameEl.title = '';
            }
        }

        // Load and display currently selected prompt on page load
        const selectedPromptId = localStorage.getItem('selectedPromptId');
        const selectedPromptName = localStorage.getItem('selectedPromptName');
        if (selectedPromptName) {
            updateSelectedPromptIndicator({ name: selectedPromptName });
        }
    });
</script>